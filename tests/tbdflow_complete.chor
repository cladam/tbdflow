# ═══════════════════════════════════════════════════════════════════════════════
# tbdflow — Workflow Completion (merge & cleanup)
# ═══════════════════════════════════════════════════════════════════════════════
# User Story: As a developer, I want to merge my short-lived branch back to
# main with a single command so that integration is fast and friction-free.
# ═══════════════════════════════════════════════════════════════════════════════

feature "tbdflow Workflow Completion"

actors: Terminal

settings {
    timeout_seconds = 30
    stop_on_failure = true
    shell_path = "/bin/bash"
}

var REPO_DIR = "/tmp/tbdflow_complete_test"
var BARE_REPO = "/tmp/tbdflow_complete_bare.git"

# ═══════════════════════════════════════════════════════════════════════════════
# IMPLEMENTATION LAYER — Tasks hide the "how"
# ═══════════════════════════════════════════════════════════════════════════════

# --- Setup drivers ---

task init_repo(repo, bare) {
    Terminal run "rm -rf ${repo} ${bare} && mkdir -p ${repo}"
    Terminal run "git init --bare ${bare}"
    Terminal run "git -C ${repo} init && git -C ${repo} commit --allow-empty -m 'init'"
    Terminal run "git -C ${repo} remote add origin ${bare}"
    Terminal run "git -C ${repo} push -u origin main"
    Terminal set_cwd "${repo}"
}

task cleanup_repo(repo, bare) {
    Terminal run "rm -rf ${repo} ${bare}"
}

# --- Action drivers ---

task create_branch(type, name) {
    Terminal run "tbdflow branch -t ${type} -n ${name}"
}

task make_change(filename, content) {
    Terminal run "echo ${content} > ${filename}"
}

task commit(type, message) {
    Terminal run "tbdflow commit -t ${type} -m '${message}'"
}

task complete_branch(type, name) {
    Terminal run "tbdflow complete -t ${type} -n ${name}"
}

task sync() {
    Terminal run "tbdflow sync"
}

task check_status() {
    Terminal run "tbdflow status"
}

# --- Condition drivers ---

task verify_branch_merged_and_deleted() {
    Terminal last_command succeeded
    Terminal output_contains "merged into main"
    Terminal output_contains "deleted"
}

task verify_on_main_with_commit(expected_message) {
    Terminal last_command succeeded
    Terminal output_contains "${expected_message}"
    Terminal output_contains "On main branch"
}

task verify_working_tree_clean() {
    Terminal last_command succeeded
    Terminal output_contains "clean"
}

# ═══════════════════════════════════════════════════════════════════════════════
# BUSINESS SPECIFICATION LAYER — Scenarios describe the "what"
# ═══════════════════════════════════════════════════════════════════════════════

# AC1: `tbdflow complete` must merge the branch back to main.
# AC2: The feature branch must be deleted after merging.
# AC3: The commit history on main must contain the work from the branch.
# AC4: The working tree must be clean after completion.

scenario "Full branch lifecycle: create, commit, complete" {

    test Setup "Initialise test repository" {
        given:
            Test can_start
        when:
            init_repo("${REPO_DIR}", "${BARE_REPO}")
        then:
            Terminal last_command succeeded
    }

    test CreateBranch "Start a short-lived feature branch" {
        given:
            Test has_succeeded Setup
        when:
            create_branch("feat", "user-settings")
        then:
            Terminal last_command succeeded
            Terminal output_contains "feat/user-settings"
            Terminal output_not_contains "Error"
    }

    test CommitWork "Commit work on the branch" {
        given:
            Test has_succeeded CreateBranch
        when:
            make_change("settings.txt", "settings_page")
            commit("feat", "add user settings page")
        then:
            Terminal last_command succeeded
            Terminal output_not_contains "Error"
    }

    test CompleteWork "Merge the branch back to main" {
        given:
            Test has_succeeded CommitWork
        when:
            complete_branch("feat", "user-settings")
        then:
            verify_branch_merged_and_deleted()
    }

    test VerifyMergeOnMain "The commit exists on main after merge" {
        given:
            Test has_succeeded CompleteWork
        when:
            sync()
        then:
            verify_on_main_with_commit("add user settings page")
    }

    test WorkingTreeClean "Working directory is clean after complete" {
        given:
            Test has_succeeded VerifyMergeOnMain
        when:
            check_status()
        then:
            verify_working_tree_clean()
    }

    after {
        cleanup_repo("${REPO_DIR}", "${BARE_REPO}")
    }
}
